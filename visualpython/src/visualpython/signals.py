"""
Signal export system for VisualPython hardware integration.

Enables exporting visual signals to CSV format for Arduino, LED strips,
and other hardware control applications.
"""

import csv
import time
import os
from typing import List, Dict, Any, Optional, Union
from dataclasses import dataclass
from pathlib import Path


@dataclass
class SignalData:
    """Represents a single signal data point for hardware export."""
    timestamp: float
    operation: str  # 'assign', 'print', 'rect', 'circle', etc.
    x: int
    y: int
    r: int  # Red component (0-255)
    g: int  # Green component (0-255)
    b: int  # Blue component (0-255)
    variable: str  # Variable name or description
    value: Union[int, float, str]  # The actual value
    metadata: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for CSV export."""
        return {
            'timestamp': self.timestamp,
            'operation': self.operation,
            'x': self.x,
            'y': self.y,
            'r': self.r,
            'g': self.g,
            'b': self.b,
            'variable': self.variable,
            'value': self.value,
            'metadata': str(self.metadata) if self.metadata else ''
        }


class AnalogSignalExporter:
    """
    Exports VisualPython signals to various formats for hardware integration.
    
    Supports CSV export, Arduino code generation, and real-time serial communication.
    """
    
    def __init__(self):
        self.signals: List[SignalData] = []
        self.export_formats = ['csv', 'arduino', 'json']
    
    def add_signal(self, signal: SignalData):
        """Add a signal to the export queue."""
        self.signals.append(signal)
    
    def clear_signals(self):
        """Clear all signals from the export queue."""
        self.signals.clear()
    
    def export_csv(self, filename: str) -> bool:
        """
        Export signals to CSV format.
        
        Args:
            filename: Output CSV file path
            
        Returns:
            True if export successful, False otherwise
        """
        try:
            with open(filename, 'w', newline='', encoding='utf-8') as f:
                if not self.signals:
                    return False
                
                # Get fieldnames from first signal
                fieldnames = list(self.signals[0].to_dict().keys())
                writer = csv.DictWriter(f, fieldnames=fieldnames)
                
                # Write header
                writer.writeheader()
                
                # Write data
                for signal in self.signals:
                    writer.writerow(signal.to_dict())
            
            return True
            
        except Exception as e:
            print(f"❌ Error exporting CSV: {e}")
            return False
    
    def export_arduino_code(self, filename: str, sketch_name: str = "VisualPython") -> bool:
        """
        Generate Arduino sketch code from signals.
        
        Args:
            filename: Output .ino file path
            sketch_name: Name of the Arduino sketch
            
        Returns:
            True if export successful, False otherwise
        """
        try:
            arduino_code = self._generate_arduino_sketch(sketch_name)
            
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(arduino_code)
            
            return True
            
        except Exception as e:
            print(f"❌ Error generating Arduino code: {e}")
            return False
    
    def _generate_arduino_sketch(self, sketch_name: str) -> str:
        """Generate Arduino sketch code from current signals."""
        
        # Extract unique variables and their ranges
        variables = {}
        for signal in self.signals:
            if signal.variable not in variables:
                variables[signal.variable] = {
                    'min': signal.value if isinstance(signal.value, (int, float)) else 0,
                    'max': signal.value if isinstance(signal.value, (int, float)) else 255,
                    'type': 'int' if isinstance(signal.value, int) else 'float'
                }
            else:
                if isinstance(signal.value, (int, float)):
                    variables[signal.variable]['min'] = min(variables[signal.variable]['min'], signal.value)
                    variables[signal.variable]['max'] = max(variables[signal.variable]['max'], signal.value)
        
        code = f'''/*
 * {sketch_name} - Generated by VisualPython
 * 
 * This Arduino sketch replays the visual signals exported from VisualPython.
 * Connect LEDs, servos, or other hardware to see your Python variables
 * control physical devices in real-time!
 * 
 * Generated: {time.strftime('%Y-%m-%d %H:%M:%S')}
 * Total signals: {len(self.signals)}
 */

// Pin definitions
#define LED_RED_PIN 9
#define LED_GREEN_PIN 10
#define LED_BLUE_PIN 11
#define SERVO_PIN 6
#define BUZZER_PIN 7

// Libraries
#include <Servo.h>

// Global variables
Servo myServo;
unsigned long lastUpdate = 0;
int signalIndex = 0;

// Signal data structure
struct Signal {{
  unsigned long timestamp;
  int r, g, b;
  int servoAngle;
  bool buzzer;
}};

// Generated signal data ({len(self.signals)} signals)
Signal signals[] = {{
'''
        
        # Generate signal data array
        for i, signal in enumerate(self.signals):
            # Map RGB values
            r = min(255, max(0, signal.r))
            g = min(255, max(0, signal.g))
            b = min(255, max(0, signal.b))
            
            # Map signal value to servo angle (0-180)
            servo_angle = 90  # Default middle position
            if isinstance(signal.value, (int, float)):
                # Map value to servo range
                if signal.value != 0:
                    servo_angle = int(90 + (signal.value % 90))  # Simple mapping
            
            # Determine buzzer state
            buzzer = signal.operation == 'print' or (isinstance(signal.value, (int, float)) and signal.value > 100)
            
            timestamp = int(signal.timestamp - self.signals[0].timestamp) * 100  # Convert to ms
            
            code += f'  {{{timestamp}, {r}, {g}, {b}, {servo_angle}, {"true" if buzzer else "false"}}}{"," if i < len(self.signals) - 1 else ""}\n'
        
        code += f'''
}};

const int TOTAL_SIGNALS = {len(self.signals)};

void setup() {{
  Serial.begin(9600);
  
  // Initialize pins
  pinMode(LED_RED_PIN, OUTPUT);
  pinMode(LED_GREEN_PIN, OUTPUT);
  pinMode(LED_BLUE_PIN, OUTPUT);
  pinMode(BUZZER_PIN, OUTPUT);
  
  // Initialize servo
  myServo.attach(SERVO_PIN);
  myServo.write(90);  // Center position
  
  Serial.println("🔥 VisualPython Arduino Controller Started!");
  Serial.println("Variables from Python will control hardware...");
  
  lastUpdate = millis();
}}

void loop() {{
  unsigned long currentTime = millis() - lastUpdate;
  
  // Check if it's time for the next signal
  if (signalIndex < TOTAL_SIGNALS && currentTime >= signals[signalIndex].timestamp) {{
    
    // Update RGB LED
    analogWrite(LED_RED_PIN, signals[signalIndex].r);
    analogWrite(LED_GREEN_PIN, signals[signalIndex].g);
    analogWrite(LED_BLUE_PIN, signals[signalIndex].b);
    
    // Update servo
    myServo.write(signals[signalIndex].servoAngle);
    
    // Update buzzer
    if (signals[signalIndex].buzzer) {{
      tone(BUZZER_PIN, 1000, 100);  // 1kHz tone for 100ms
    }}
    
    // Debug output
    Serial.print("Signal ");
    Serial.print(signalIndex);
    Serial.print(": RGB(");
    Serial.print(signals[signalIndex].r);
    Serial.print(",");
    Serial.print(signals[signalIndex].g);
    Serial.print(",");
    Serial.print(signals[signalIndex].b);
    Serial.print(") Servo:");
    Serial.print(signals[signalIndex].servoAngle);
    Serial.print(" Buzzer:");
    Serial.println(signals[signalIndex].buzzer ? "ON" : "OFF");
    
    signalIndex++;
  }}
  
  // Reset and loop when all signals are played
  if (signalIndex >= TOTAL_SIGNALS) {{
    Serial.println("🔄 Restarting signal sequence...");
    signalIndex = 0;
    lastUpdate = millis();
    delay(2000);  // Pause before restart
  }}
  
  delay(10);  // Small delay for stability
}}

/*
 * Hardware Connections:
 * 
 * RGB LED:
 *   - Red   → Pin 9  (PWM)
 *   - Green → Pin 10 (PWM)
 *   - Blue  → Pin 11 (PWM)
 *   - GND   → GND
 * 
 * Servo:
 *   - Signal → Pin 6
 *   - VCC    → 5V
 *   - GND    → GND
 * 
 * Buzzer:
 *   - Positive → Pin 7
 *   - Negative → GND
 * 
 * Upload this sketch to your Arduino and watch your Python
 * variables come to life as lights, motion, and sound!
 */
'''
        
        return code
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get statistics about the current signal data."""
        if not self.signals:
            return {}
        
        operations = {}
        variables = set()
        time_range = (self.signals[0].timestamp, self.signals[-1].timestamp)
        
        for signal in self.signals:
            operations[signal.operation] = operations.get(signal.operation, 0) + 1
            variables.add(signal.variable)
        
        return {
            'total_signals': len(self.signals),
            'operations': operations,
            'unique_variables': len(variables),
            'variables': list(variables),
            'time_range_seconds': time_range[1] - time_range[0],
            'start_time': time_range[0],
            'end_time': time_range[1]
        }


class HardwareSignalController:
    """
    Real-time hardware communication controller.
    
    Manages serial communication with Arduino and other microcontrollers
    for live hardware control during VisualPython execution.
    """
    
    def __init__(self, port: str = None, baudrate: int = 9600):
        self.port = port
        self.baudrate = baudrate
        self.connection = None
        self.is_connected = False
        
        # Try to import pyserial
        try:
            import serial
            self.serial = serial
        except ImportError:
            self.serial = None
            print("⚠️  pyserial not available. Install with: pip install pyserial")
    
    def connect(self, port: str = None) -> bool:
        """
        Connect to hardware device.
        
        Args:
            port: Serial port (e.g., 'COM3' on Windows, '/dev/ttyUSB0' on Linux)
            
        Returns:
            True if connection successful
        """
        if not self.serial:
            return False
        
        try:
            if port:
                self.port = port
            
            if not self.port:
                # Auto-detect port
                ports = self.serial.tools.list_ports.comports()
                if ports:
                    self.port = ports[0].device
                else:
                    print("❌ No serial ports found")
                    return False
            
            self.connection = self.serial.Serial(self.port, self.baudrate, timeout=1)
            self.is_connected = True
            
            print(f"✅ Connected to hardware on {self.port}")
            return True
            
        except Exception as e:
            print(f"❌ Failed to connect to {self.port}: {e}")
            return False
    
    def disconnect(self):
        """Disconnect from hardware device."""
        if self.connection:
            self.connection.close()
            self.connection = None
            self.is_connected = False
            print("🔌 Disconnected from hardware")
    
    def send_signal(self, signal: SignalData) -> bool:
        """
        Send a signal to the connected hardware device.
        
        Args:
            signal: Signal data to send
            
        Returns:
            True if sent successfully
        """
        if not self.is_connected or not self.connection:
            return False
        
        try:
            # Format signal as simple command string
            command = f"{signal.operation},{signal.r},{signal.g},{signal.b},{signal.value}\n"
            self.connection.write(command.encode())
            return True
            
        except Exception as e:
            print(f"❌ Error sending signal: {e}")
            return False


# Convenience functions for easy usage

def export_signals(signals: List[Any], filename: str = "signals.csv") -> bool:
    """
    Export VisualPython signals to CSV format.
    
    Args:
        signals: List of signal data (can be raw lists or SignalData objects)
        filename: Output filename
        
    Returns:
        True if export successful
    """
    exporter = AnalogSignalExporter()
    
    # Convert raw signals to SignalData objects if needed
    for signal in signals:
        if isinstance(signal, SignalData):
            exporter.add_signal(signal)
        elif isinstance(signal, (list, tuple)) and len(signal) >= 9:
            # Convert from raw list format [timestamp, operation, x, y, r, g, b, variable, value]
            signal_data = SignalData(
                timestamp=signal[0],
                operation=signal[1],
                x=signal[2],
                y=signal[3],
                r=signal[4],
                g=signal[5],
                b=signal[6],
                variable=signal[7],
                value=signal[8]
            )
            exporter.add_signal(signal_data)
    
    success = exporter.export_csv(filename)
    
    if success:
        stats = exporter.get_statistics()
        print(f"✅ Exported {stats['total_signals']} signals to {filename}")
        print(f"📊 Operations: {stats['operations']}")
        print(f"🔧 Variables: {', '.join(stats['variables'])}")
    
    return success


def quick_export_arduino(signals: List[Any], filename: str = "visualpython_arduino.ino") -> bool:
    """
    Quick export of signals to Arduino sketch format.
    
    Args:
        signals: List of signal data
        filename: Output Arduino sketch filename
        
    Returns:
        True if export successful
    """
    exporter = AnalogSignalExporter()
    
    # Convert signals like export_signals function
    for signal in signals:
        if isinstance(signal, SignalData):
            exporter.add_signal(signal)
        elif isinstance(signal, (list, tuple)) and len(signal) >= 9:
            signal_data = SignalData(
                timestamp=signal[0],
                operation=signal[1],
                x=signal[2],
                y=signal[3],
                r=signal[4],
                g=signal[5],
                b=signal[6],
                variable=signal[7],
                value=signal[8]
            )
            exporter.add_signal(signal_data)
    
    success = exporter.export_arduino_code(filename)
    
    if success:
        print(f"🔧 Generated Arduino sketch: {filename}")
        print(f"📡 Hardware control code ready for upload!")
        print(f"💡 Connect RGB LED to pins 9,10,11 and servo to pin 6")
    
    return success


def create_hardware_controller(port: str = None) -> Optional[HardwareSignalController]:
    """
    Create and connect a hardware signal controller.
    
    Args:
        port: Serial port to connect to (auto-detect if None)
        
    Returns:
        Connected controller or None if failed
    """
    controller = HardwareSignalController()
    
    if controller.connect(port):
        return controller
    else:
        return None